//NOT GENERATED BY MKUROM
//namded id_t to avoid acidently being overritten if someboyd runs one of the older version of the mkurom

module id_t(

    input logic [31:0] instr,
    output logic [4:0] rs1,
    output logic [4:0] rs2,
    output logic [4:0] rd,
    output logic [31:0] im
    
);

    always_comb begin
        unique case(instr[6:0]) //opcode

            7'b0110011: begin //R-type
                rs2 = instr[24:20];
                rs1 = instr[19:15];
                rd = instr[11:7];
                im = 32'h0;
            end

            7'b0010011: begin //I-type(IMMS)
                rs2 = '0;
                rs1 = instr[19:15];
                rd = instr[11:7];
                //im[11:0] = instr[31:20];
                im = {{20{instr[31]}}, instr[31:20]}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            7'b0000011: begin //I-type(LOADS)
                rs2 = '0;
                rs1 = instr[19:15];
                rd = instr[11:7];
                //im[11:0] = instr[31:20];
                im = {{20{instr[31]}}, instr[31:20]}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            7'b1100111: begin //I-type(JALR)
                rs2 = '0;
                rs1 = instr[19:15];
                rd = instr[11:7];
                //im[11:0] = instr[31:20];
                im = {{20{instr[31]}}, instr[31:20]}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            7'b0001111: begin //I-type(MISC-MEM)
                rs2 = '0;
                rs1 = instr[19:15];
                rd = instr[11:7];
                //im[11:0] = instr[31:20];
                im = {{20{instr[31]}}, instr[31:20]}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            7'b1110011: begin //I-type(SYSTEMS)
                rs2 = '0;
                rs1 = instr[19:15];
                rd = instr[11:7];
                //im[11:0] = instr[31:20];
                im = {{20{instr[31]}}, instr[31:20]}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            7'b0100011: begin //S-type
                rs2 = instr[24:20];
                rs1 = instr[19:15];
                rd = '0;
                //im[11:0] = {instr[31:25], instr[11:7]};
                im = {{20{instr[31]}}, instr[31:25], instr[11:7]}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            7'b1100011: begin //B-type
                rs2 = instr[24:20];
                rs1 = instr[19:15];
                rd = '0;
                //im[12:0] = {instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}'
                im = {{19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            7'b0110111: begin //U-type(LUI)
                rs2 = '0;
                rs1 = '0;
                rd = instr[11:7];
                //im[31:12] = instr[31:12];
                im = {instr[31:12], 12'h0};
            end

            7'b0010111: begin //U-type(AUIPC)
                rs2 = '0;
                rs1 = '0;
                rd = instr[11:7];
                //im[31:12] = instr[31:12];
                im = {instr[31:12], 12'h0};
            end                    

            7'b1101111: begin //J-type
                rs2 = '0;
                rs1 = '0;
                rd = instr[11:7];
                //im[20:0] = {instr[31], instr[19:12], instr[20], instr[30:21], 1'b0};
                im = {{11{instr[31]}}, instr[31], instr[19:12], instr[20], instr[30:21], 1'b0}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            default : {rs2,rs1,rd,im} = '0;

        endcase
    end


endmodule