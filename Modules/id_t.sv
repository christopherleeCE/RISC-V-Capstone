//NOT GENERATED BY MKUROM
//namded id_t to avoid acidently being overritten if someboyd runs one of the older version of the mkurom

module id_t(

    input logic [31:0] instr,
    output logic [4:0] rs1,
    output logic [4:0] rs2,
    output logic [4:0] rd,
    output logic [31:0] im,
    input logic r_type, i_type, s_type, b_type, u_type, j_type
    
);

    always_comb begin
        unique case(1'b1)

            r_type: begin
                rs2 = instr[24:20];
                rs1 = instr[19:15];
                rd = instr[11:7];
                im = 32'h0;
            end

            i_type: begin
                rs2 = '0;
                rs1 = instr[19:15];
                rd = instr[11:7];
                //im[11:0] = instr[31:20];
                im = {{20{instr[31]}}, instr[31:20]}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            s_type: begin
                rs2 = instr[24:20];
                rs1 = instr[19:15];
                rd = '0;
                //im[11:0] = {instr[31:25], instr[11:7]};
                im = {{20{instr[31]}}, instr[31:25], instr[11:7]}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            b_type: begin
                rs2 = instr[24:20];
                rs1 = instr[19:15];
                rd = '0;
                //im[12:0] = {instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}'
                im = {{19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

            u_type: begin
                rs2 = '0;
                rs1 = '0;
                rd = instr[11:7];
                //im[31:12] = instr[31:12];
                im = {instr[31:12], 12'h0};
            end

            j_type: begin
                rs2 = '0;
                rs1 = '0;
                rd = instr[11:7];
                //im[20:0] = {instr[31], instr[19:12], instr[20], instr[30:21], 1'b0};
                im = {{11{instr[31]}}, instr[31], instr[19:12], instr[20], instr[30:21], 1'b0}; //sign extending, so if zero, gets padded w/ zeros, but if negative (sign bit = 1), get padded w/ 1's
            end

        endcase
    end


endmodule